---
slug: "01-blog"
id: "blog-001"
date: "2025-12-04"
order: 0
author: "Eric Lucero"
socialThumbnail: https://res.cloudinary.com/dcvnw6hvt/image/upload/v1765057574/elCronopio/Thumbnails/sorteo_es_gr5u4w.png
webThumbnail: https://res.cloudinary.com/dcvnw6hvt/image/upload/v1765043191/elCronopio/individuo-6_s8wgyw.jpg
title: "Un Algoritmo Gen√©tico para generar el Sorteo de Grupos de la Copa Mundial de la FIFA"
shortTitle: "Grupos del mundial con Algoritmos Gen√©ticos"
entryType: "blog"
excerpt: "Hackeando el Mundial 2026: C√≥mo los Algoritmos Gen√©ticos resuelven lo que la fuerza bruta no puede."
doctype: ["blog", "python"]
isPublic: true
---
La Copa Mundial de la FIFA 2026 ser√° la primera en disputarse entre 48 selecciones nacionales de todo el mundo.
Estos 48 equipos deben distribuirse en 12 grupos y se reparten de forma particular a trav√©s de un sorteo que pone algunas restricciones interesante en la formaci√≥n de estos grupos, gracias a estas
el sorteo se puede llevar a cabo de forma r√°pida y sin problemas.
Una vez hecho el sorteo queda determinado c√≥mo se enfrentar√°n los equipos en la fase inicial. 

En la edici√≥n de 2026, con 48 equipos participantes, el sorteo se vuelve a√∫n m√°s complejo debido a las m√∫ltiples restricciones que deben cumplirse<CitationSup id="1" />.

El problema al que nos enfrentamos al generar el sorteo de grupos es un problema de optimizaci√≥n combinatoria con restricciones.
Solo hay un n√∫mero limitado de combinaciones posibles que cumplen con todas las restricciones impuestas por la FIFA, a esto se le llama 
_soluciones factibles_. 

### Soluci√≥n factible
Una soluci√≥n factible es aquella que satisface la funci√≥n objetivo y no viola ninguna de las restricciones del problema o al menos aquellas son consideradas obligatorias.

En el caso de los grupos del mundial, la soluci√≥n factible es una configuraci√≥n del sorteo que cumple con todas las restricciones impuestas, como la distribuci√≥n de confederaciones y el ranking de los equipos.
La mayor√≠a de las combinaciones posibles que se pueden hacer con 48 equipos, 4 bombos y 12 grupos no ser√°n soluciones factibles. 
Aqu√≠ radica la dificultad del problema, en encontrar un sorteo que sea v√°lido para todas las restricciones del sorteo.

Este espacio de soluciones puede ser extremadamente grande y complejo, especialmente cuando se consideran todas las restricciones de confederaciones y de ranking de equipos.
Por ejemplo, en el Mundial de 2026, con 48 equipos y m√∫ltiples restricciones, el n√∫mero de configuraciones posibles del sorteo es astron√≥mico. Vamos a calcularlo.

### Combinaciones posibles
En el sorteo hay 42 equipos distribuidos en 4 bombos (recipientes) que van a ser distribuidos en 12 grupos (del A al L). De cada bombo se ir√°n sacando los equipos de forma aleatoria hasta vaciar el bombo, de tal manera que cada grupo tendr√° un equipo de cada bombo.
Los anfitriones (Canad√°, M√©xico y Estados Unidos) ya tienen asignado su grupo, y en cada bombo hay 12 equipos. 

Ahora calculemos todas las __combinaciones posibles__ sin considerar las restricciones y usando factoriales ($n!$).
- Bombo 1: $9!$,
- Bombos 2, 3, y 4: $12!$
- Esto es en total: $9! \times  12! \times 12! \times12! = 3.9881 \times 10^{31}$ combinaciones posibles.
>__¬øQu√© tan grande es este n√∫mero?__
>39, 881, 724, 135, 495, 319, 399, 956, 480, 000, 000 combinaciones posibles de organizar los equipos en los grupos. Ignorando las restricciones.

>Para tener una idea de la magnitud de este n√∫mero, si pudi√©ramos evaluar cada sorteo generado por nuestro algoritmo de fuerza bruta en 0.05 segundos, evaluar todas las soluciones posibles tardar√≠a $6.3 \times 10^{22}$ a√±os.
Si el algoritmo hubiera iniciado en el Big Bang, a√∫n no habr√≠a terminado, de hecho llevar√≠a el 0.00000000002% del tiempo total.

De tal manera que un algoritmo de fuerza bruta, aquel que va generando todas las combinaciones posibles hasta dar con alguna que no viole las restricciones, 
es decir que sea factible, puede tardar mucho tiempo incluso millones de a√±os.
Por suerte existen algoritmos de optimizaci√≥n cuya b√∫squeda es mucho m√°s eficiente que los de fuerza bruta y reducen este tiempo a un par de segundos.
En el caso del sorteo de grupos de la Copa Mundial de la FIFA, usaremos un algoritmo gen√©tico.

### Restricciones del sorteo
Las restricciones del sorteo definen lo que debe suceder al ir sacando los equipos de los bombos para asignarlos a los grupos. La FIFA ha 
redefinido las restricciones para este mundial de 2026 ya que es el primero con 42 selecciones y 12 grupos.

Primero hay que aclarar que en el sorteo los nombres de las 42 selecciones est√°n divididas en cuatro recipientes (bombos) ordenadas seg√∫n aparecen en el Ranking FIFA <CitationSup id="2" />.

Las restricciones son las siguientes <CitationSup id="3" />:
- _Anfitriones:_ M√©xico se le asignar√° la posici√≥n A1 (primero del grupo A), a Canad√°, la posici√≥n B1, y a Estados Unidos, la posici√≥n D1.
- _Bombo 1:_ Las otras nueve selecciones del bombo 1 se identificar√°n mediante nueve bolas del mismo color y se asignar√°n autom√°ticamente a la posici√≥n 1 del grupo en el que resulten encuadradas.
- _Distribuci√≥n uniforme:_ En cada grupo debe haber un equipo de cada bombo. 
- _Confederaciones por grupo:_ Ning√∫n grupo puede tener m√°s de una selecci√≥n de la misma confederaci√≥n, excepto las de la UEFA, que pueden tener hasta dos selecciones en un mismo grupo.
- _Top 4 del ranking:_ Por √∫ltimo, las selecciones de Espa√±a y Argentina por un lado, y Francia e Inglaterra por otro, no podr√°n enfrentarse hasta la semifinal, por ser los cuatro primeros 
del ranking masculino de la FIFA a la fecha<CitationSup id="2" />. Esto restringe que se agreguen a cualquier grupo.

Esto es lo que llamamos *restricciones* del problema.
Intentar generar todas las combinaciones posibles y luego filtrar las que cumplen con las restricciones ser√≠a computacionalmente inviable como ya hemos visto.

## ¬øQu√© es un Algoritmo Gen√©tico?
Sin entrar en muchos detalles un algoritmos gen√©tico (GA en ingl√©s) es un algoritmo de optimizaci√≥n inspirado en la reproducci√≥n de poblaciones de generaci√≥n en 
generaci√≥n y en los procesos biol√≥gicos de evoluci√≥n. Est√°n enmarcados dentro de los llamados _algoritmos evolutivos_. 

Las bases te√≥ricas y primeras ideas de los algoritmos gen√©ticos
pertenecen a los trabajos de John Holland y Lawrence Fogel en los a√±os 60s<CitationSup id='4'/><CitationSup id='5'/>.

Un algoritmo gen√©tico se compone de un poblaciones de individuos que representan las soluciones candidatas al problema que se quiere resolver.
Cada una de estas soluciones se eval√∫a mediante una funci√≥n de costo, aptitud o _fitness_ que mide qu√© tan buena es la soluci√≥n.
Luego, se seleccionan las mejores soluciones para reproducirse y generar nuevas soluciones mediante operaciones de _cruce_ y _mutaci√≥n_.

Este proceso se repite durante varias generaciones hasta que se alcance un criterio de terminaci√≥n, como un n√∫mero m√°ximo de generaciones o una soluci√≥n suficientemente buena.

## Poblaci√≥n inicial

Los algoritmos gen√©ticos forman parte del conjunto de __metaheur√≠sticas__ llamadas o clasificadas como poblacionales. 
En este tipo de algoritmos se eval√∫a un conjunto de soluciones en cada alteraci√≥n el cual llamamos poblaci√≥n. Cada poblaci√≥n est√° conformada por individuos y cada uno de estos debe ser evaluado por la funci√≥n de costo.
En el mejor de los casos se llegar√° una soluci√≥n cuando se encuentre un individuo que tenga el √≥ptimo Fitness y no incurra en ninguna violaci√≥n a ninguna de las restricciones.

En nuestro caso, para este problema cada individuo es un sorteo, como ya hemos dicho. Este individuo puede contener esquemas que violen las reglas y las restricciones del sorteo,
Y es la funci√≥n de Fitness qui√©n va a castigar asign√°ndole valores que cada vez lo alejen del √≥ptimo a este individuo. 

Antes de definir la poblaci√≥n es importante definir primero los individuos que conforman poblaci√≥n
A esto le llamamos codificaci√≥n del individuo.
Cada individuo de la poblaci√≥n es un sorteo, como ya hemos dicho, el cual debemos encontrar una forma de representarlo en algoritmo y crearlo (codificaci√≥n).



En el siguiente c√≥digo se ve el proceso de creaci√≥n de un individuo en un procedimiento parecido al sorteo, es decir se van asignando los equipos bombo por bombo, desde el primero hasta el cuarto.
Ignorando la restricciones, los individuos pueden ser individuos v√°lidos o no, seg√∫n violen o no las restricciones. 
_Es el algoritmo que debe determinar qui√©n es el mejor o el √≥ptimo de todos los individuos._

```python
def crear_individuo(lista_equipos):
    # Crear un individuo (sorteo) v√°lido inicial
    bombos = {1: [], 2: [], 3: [], 4: []}
    # Distribuir equipos por bombo
    for eq in lista_equipos:
        bombos[eq.bombo].append(eq)
    # Asignar equipos a grupos
    grupos = [[] for _ in range(12)]
    for b in range(1, 5):
        equipos = bombos[b]
        # Mezclar para aleatoriedad
        random.shuffle(equipos)
        pendientes = []
        for eq in equipos:
            if eq.grupo_fijo:
                # Asignar al grupo fijo y saltar (convierte letra del grupo a √≠ndice)
                idx = ord(eq.grupo_fijo) - 65
                grupos[idx].append(eq)
            else:
                pendientes.append(eq)
        idx_p = 0
        # Asignar restantes de este bombo
        for g_idx in range(12):
            if len(grupos[g_idx]) < b:
                grupos[g_idx].append(pendientes[idx_p])
                idx_p += 1
    return grupos
```

### Estructura del individuo
Ya hemos dicho que cada individuo del algoritmo gen√©tico representa una soluci√≥n candidata al problema. Esto es 
_un sorteo de grupos_ con los 12 grupos completos, sin importar si son v√°lidos o no. Como cada sorteo est√° compuesto por grupos, cada grupo representa lo que 
llamamos un _gen_ dentro del individuo.

![caption=Representaci√≥n de un individuo como un sorteo completo de 12 grupos y 48 equipos.](https://res.cloudinary.com/dcvnw6hvt/image/upload/v1765043191/elCronopio/individuo-6_s8wgyw.jpg)

Para nuestro c√≥digo, cada _gen_ est√° formado por elementos de la clase `Equipo` que contiene la informaci√≥n relevante de cada selecci√≥n nacional:
```python

class Equipo:
    def __init__(self, nombre, confederacion, bombo, grupo_fijo=None, ranking_top=None):
        self.nombre = nombre
        self.confederacion = confederacion  # String simple
        self.bombo = bombo
        self.grupo_fijo = grupo_fijo
        self.ranking_top = ranking_top  # 1, 2, 3, 4 o None

    def __repr__(self):
        # Muestra info √∫til al imprimir
        r = f" [R#{self.ranking_top}]" if self.ranking_top else ""
        f = f" (Fijo:{self.grupo_fijo})" if self.grupo_fijo else ""
        return f"{self.nombre}{r}{f}"
```
Por ejemplo un equipo del top 4 se representar√≠a as√≠:
```python
Equipo("Espa√±a", "UEFA", 1, ranking_top=1)
Equipo("Argentina", "CONMEBOL", 1, ranking_top=2)
```
Y los equipos anfitriones con grupo fijo:
```python
Equipo("M√©xico", "CONCACAF", 1, grupo_fijo="A")
Equipo("Canad√°", "CONCACAF", 1, grupo_fijo="B")
```
El resto de los equipos se instancia a la clase Equipo de forma m√°s sencilla:
```python
Equipo("Alemania", "UEFA", 1)
Equipo("Ecuador", "CONMEBOL", 2)
Equipo("Panam√°", "CONCACAF", 3)
# Y asi hasta completar el resto...
```

## Fitness Function o Funci√≥n de costo

La forma m√°s sencilla de evaluar un individuo de estas caracter√≠sticas, es creando una funci√≥n objetivo que cuente las veces que se violan la restricciones, 
y en cada una de estas le adjudique una penalizaci√≥n a ese individuo,
es decir una valoraci√≥n desfavorable de tal manera que en el _ciclo de vida_ del algoritmo este individuo quede rezagado o no pueda reproducirse y se extinga.

![caption=Evaluaci√≥n de dos individuos. El individuo A tiene un fitness de 900, ya que viola la repetici√≥n de confederaciones en los grupos C,D,E. Adem√°s de no separar los itinerarios de Espa√±a y Argentina.](https://res.cloudinary.com/dcvnw6hvt/image/upload/v1765043190/elCronopio/fitness-11_y0fggo.jpg)

El algoritmo busca minimizar este n√∫mero. Un fitness de 1400 es un desastre; un fitness de 0 es un sorteo v√°lido.

La funci√≥n `calcularFitness(sorteo)` es el motor del algoritmo. Su objetivo es llegar a cero, esto significa que ha encontrado un individuo cuya evaluaci√≥n no viola ninguna de las restricciones,

Al encontrar uno de estos el algoritmo ha encontrado el √≥ptimo, es decir un sorteo v√°lido. Aqu√≠ es donde entran en el juego las restricciones mencionadas anteriormente.

Aqu√≠ aplicamos Restricciones Duras (Hard Constraints):
- Confederaciones: Ning√∫n grupo puede tener m√°s de un equipo de la misma confederaci√≥n (salvo Europa, que permite dos).
```python
        for conf, cant in conteo_confs.items():
            if conf == "UEFA":
                if cant > 2:
                    penalizacion += 100
            else:
                if cant > 1:
                    penalizacion += 100
```
- Itinerarios: Los cabezas de serie del Top 4 deben estar distribuidos en llaves opuestas para no enfrentarse antes de la semifinal. Si el Top 1 y Top 2 caen en el mismo grupo, 
aplicamos una penalizaci√≥n masiva (+500).
```python
  if 1 in ubicacion_tops and 2 in ubicacion_tops:
        it_1 = obtener_itinerario(ubicacion_tops[1])
        it_2 = obtener_itinerario(ubicacion_tops[2])
        if it_1 == it_2:
            penalizacion += 500  # ¬°Fallo Grave!
```
Veamos la funci√≥n de costo completa. Su objetivo es evaluar cada grupo y contar las veces que se viola alguna restricci√≥n y penalizarla. 
```python
def calcular_fitness(sorteo):
    penalizacion = 0

    # Rastrear d√≥nde cayeron los Top 4
    ubicacion_tops = {}

    # --- Bucle por Grupos ---
    for i, grupo in enumerate(sorteo):
        conteo_confs = {}

        for equipo in grupo:
            # A. Guardar ubicaci√≥n de Tops
            if equipo.ranking_top:
                ubicacion_tops[equipo.ranking_top] = i

            # B. Contar confederaciones (Simplificado)
            conf = equipo.confederacion
            conteo_confs[conf] = conteo_confs.get(conf, 0) + 1

        # C. Penalizaciones de confederaci√≥n
        for conf, cant in conteo_confs.items():
            if conf == "UEFA":
                if cant > 2:
                    penalizacion += 100
            else:
                if cant > 1:
                    penalizacion += 100

    # --- Penalizaciones de Itinerario ---
    # Regla: 1 (Espa√±a) vs 2 (Argentina) en itinerarios distintos
    if 1 in ubicacion_tops and 2 in ubicacion_tops:
        it_1 = obtener_itinerario(ubicacion_tops[1])
        it_2 = obtener_itinerario(ubicacion_tops[2])
        if it_1 == it_2:
            penalizacion += 500  # ¬°Fallo Grave!

    # Regla: 3 (Francia) vs 4 (Inglaterra) en itinerarios distintos
    if 3 in ubicacion_tops and 4 in ubicacion_tops:
        it_3 = obtener_itinerario(ubicacion_tops[3])
        it_4 = obtener_itinerario(ubicacion_tops[4])
        if it_3 == it_4:
            penalizacion += 500  # ¬°Fallo Grave!

    return penalizacion

```

## Ciclo de vida del Algoritmo Gen√©tico
En un algoritmo poblacional se crea la poblaci√≥n de individuos, y se recorre esta poblaci√≥n evaluando el costo de cada uno de estos en busca del √≥ptimo,
de no encontrar ninguno se deben recurrir a __operadores gen√©ticos__, que son los encargados de hacer variaciones en la poblaci√≥n para generar nuevos individuos.

Estos operadores son los de _mutaci√≥n_ y _cruce_, simulando los aspectos de la gen√©tica. La mutaci√≥n equivale a tomar un individuo (cromosoma) y cambiarle un elemento (gen) de forma aleatoria.
El cruce simula la reproducci√≥n de dos individuos. Consiste en tomar dos individuos e intercambiar material gen√©tico (secciones del individuo) entre uno y otro. Tanto el cruce como la mutaci√≥n
tienen muchas variantes<CitationSup id="6"/>, en este caso aplicamos las m√°s sencillas que son las que hemos definido anteriormente.

En el caso concreto del sorteo, el cruce se hace tomando dos individuos por el mecanismo de ruleta, estos dos van a hacer el rol de padre y madre que van a reproducirse para generar un hijo, este hijo va a ser el nuevo individuo generado.

La funci√≥n `cruzar` toma dos padres y de forma aleatoria decide cu√°l va a ser el donante y receptor (aunque realmente los dos donan), cada uno de estos donantes va a intercambiar todos los grupos que ha recibido de un bombo con el otro padre.

```python
def ejecutar_ga_completo():
    # --- CONFIGURACI√ìN ---
    POBLACION_TAM = 10
    GENERACIONES = 1000
    PROB_CROSSOVER = 0.8  # 80% probabilidad de cruce
    PROB_MUTACION = 0.2  # 20% probabilidad de mutaci√≥n
    K_TORNEO = 2  # Tama√±o del torneo para selecci√≥n

    datos = generar_datos_usuario()
    poblacion = [crear_individuo(datos) for _ in range(POBLACION_TAM)]

    print(f"üß¨ Iniciando GA (Pc={PROB_CROSSOVER}, Pm={PROB_MUTACION})...")

    for gen in range(GENERACIONES):
        # Evaluar Fitness
        # Guardamos (score, individuo)
        evaluados = [(calcular_fitness(ind), ind) for ind in poblacion]
        evaluados.sort(key=lambda x: x[0])

        best_score = evaluados[0][0]
        # Monitorizaci√≥n
        if gen % 100 == 0 or best_score == 0:
            print(f"Gen {gen}: Mejor Coste = {best_score}")

        if best_score == 0:
            print(f"‚úÖ ¬°SOLUCI√ìN PERFECTA ENCONTRADA EN GEN {gen}!")
            return evaluados[0][1]

        # Selecci√≥n (Torneo simple)
        nueva_poblacion = []

        while len(nueva_poblacion) < POBLACION_TAM:
            
            # OPCI√ìN A: TORNEO
            # padre1 = seleccion_torneo(evaluados, k=K_TORNEO)
            # padre2 = seleccion_torneo(evaluados, k=K_TORNEO)

            # OPCI√ìN B: RULETA
            padre1 = seleccion_ruleta(evaluados)
            padre2 = seleccion_ruleta(evaluados)

            # Crossover sujeto a probabilidad (0.8)
            if random.random() < PROB_CROSSOVER:
                hijo1, hijo2 = cruzar(padre1, padre2)
            else:
                hijo1, hijo2 = copy.deepcopy(padre1), copy.deepcopy(padre2)
            # Mutaci√≥n sujeta a probabilidad (0.2)
            hijo1 = mutar(hijo1, PROB_MUTACION)
            hijo2 = mutar(hijo2, PROB_MUTACION)

            nueva_poblacion.append(hijo1)
            if len(nueva_poblacion) < POBLACION_TAM:
                nueva_poblacion.append(hijo2)
        poblacion = nueva_poblacion

    print("‚ö†Ô∏è L√≠mite alcanzado. Devolviendo mejor aproximaci√≥n.")
    return evaluados[0][1]
```    

## Operadores Gen√©ticos

El primer operador en ser aplicado es llamado _selecci√≥n_. El objetivo de la selecci√≥n es simular la ley de Darwiniana de la supervivencia del m√°s apto. 
Como los dem√°s operadores, hay muchas formas de hacer el operador de selecci√≥n y entre los m√°s usados est√°n los operadores de _ruleta_ y _torneo_. 

En el operador de torneo se van tomando pares de individuos y se compara su valor de fitness, en cada par o el ganador "clasifica" y se enfrenta con los otros ganadores hasta obtener un ganador del torneo. Este es el seleccionado para el cruce.

El operador de ruleta simula el comportamiento de una ruleta, sin embargo los espacios o las divisiones de esta ruleta no son iguales. La probabilidad de selecci√≥n de un individuo es proporcional a su valor de fitness.
A mayor fitness, mayor probabilidad de ser seleccionado. Los individuos seleccionados forman parte de los padres de los cuales surgir√° la nueva poblaci√≥n de individuos con los otros operadores gen√©ticos.

### Selecci√≥n
No dejamos que cualquiera se reproduzca. Se utiliza el operador de ruleta, aunque tambi√©n aparece en el c√≥digo el operador de torneo.
Este operador toma todos los individuos de una generaci√≥n y crea un arreglo llamado `pesos` que contiene el inverso del valor del fitness de cada uno de estos, luego selecciona uno aleatoriamente
Con la funci√≥n `random.choices()` qu√© asigna un individuo de forma aleatoria, pero con una probabilidad proporcional a su valor de fitness, lo que en el c√≥digo designamos con la variable `pesos`.
Este proceso se repite para generar cada Padre, para cada individuo en cada generaci√≥n. Lo que genera suficientes individuos para reemplazar totalmente (en igual n√∫mero) a todos los individuos de una generaci√≥n.

```python
def seleccion_ruleta(evaluados):
    """
    Input: Lista de tuplas (fitness, individuo)
    Selecci√≥n proporcional al fitness (Ruleta).
    Como buscamos MINIMIZAR el costo, invertimos el valor.
    Fitness 0 -> Peso muy alto. Fitness 500 -> Peso bajo.
    """
    individuos = [item[1] for item in evaluados]
    costos = [item[0] for item in evaluados]

    # Invertimos los costos para obtener pesos (Mayor peso = Mayor probabilidad)
    pesos = [1.0 / (1.0 + c) for c in costos]

    # La funci√≥n choices de 3 argumentos (poblaci√≥n, pesos, cantidad)
    seleccionado = random.choices(population=individuos, weights=pesos, k=1)[0]

    return seleccionado
```


### Cruce

![caption=Ejemplo del operador de cruce. En la imagen vemos que el Padre A dona todos los equipos que pertenecen a los bombos 1 y 4 al hijo A, y los equipos del bombo 2 y 3 al hijo B.](https://res.cloudinary.com/dcvnw6hvt/image/upload/v1765043192/elCronopio/FIFA-cruce-6_mkwaqe.jpg)

El cruce es el operador m√°s importante, ya que es el responsable de crear diversidad y explorar el espacio de b√∫squeda. El cruce toma dos padres y crea un hijo.
Lo que da lugar al reemplazo de la poblaci√≥n actual por una nueva generaci√≥n. En nuestro caso debemos tener mucho cuidado ya que no podemos hacer un cruce en cualquier punto del individuo (cromosoma)
 si hacemos esto y cortamos un sorteo por la mitad y lo intercambiamos por otro, romper√≠amos la estructura de los bombos.

El operador de cruce definido en la funci√≥n `cruzar()` opera bombo por bombo. Para el Bombo 1 (Cabezas de serie), lanza una moneda: ¬øHereda la distribuci√≥n del Padre A o del B?
Repite para los Bombos 2, 3 y 4.

Esto garantiza que el hijo sea estructuralmente v√°lido (siempre habr√° un equipo de cada bombo en cada grupo) pero gen√©ticamente nuevo.


Para cada bombo (1, 2, 3, 4):
  - Lanza moneda: ¬øde qu√© padre heredar este bombo?
  - Hijo1 hereda bombo completo del padre elegido
  - Hijo2 hereda bombo completo del otro padre

Resultado: 2 nuevos sorteos (hijos)

```python

def cruzar(padre1, padre2):
    """
    Operador de Cruce Estratificado (Uniform Crossover por Bombos).
    El hijo hereda la configuraci√≥n entera de un bombo de uno de los padres.
    """
    # Hijos vac√≠os
    hijo1 = [[] for _ in range(12)]
    hijo2 = [[] for _ in range(12)]
    # Recorremos cada nivel de Bombo (0 a 3)
    for bombo_idx in range(4):
        # Decisi√≥n aleatoria: ¬øQui√©n dona este bombo?
        if random.random() < 0.5:
            # Caso A: Hijo 1 hereda de Padre 1, Hijo 2 hereda de Padre 2
            donante_1 = padre1
            donante_2 = padre2
        else:
            # Caso B: Cruzado
            donante_1 = padre2
            donante_2 = padre1

        # Copiamos la fila entera de ese bombo a los hijos
        for g_idx in range(12):
            equipo_p1 = donante_1[g_idx][bombo_idx]
            equipo_p2 = donante_2[g_idx][bombo_idx]

            hijo1[g_idx].append(equipo_p1)
            hijo2[g_idx].append(equipo_p2)
    return hijo1, hijo2
```

### Mutaci√≥n
Si solo cruzamos padres, eventualmente todos los hijos se parecer√°n y nos estancaremos en un "M√≠nimo Local" (una soluci√≥n que parece buena pero no es la mejor).

![caption=Ejemplo del operador de mutaci√≥n.](https://res.cloudinary.com/dcvnw6hvt/image/upload/v1765043192/elCronopio/Fifa-mutar-7_grtdqh.jpg)

La funci√≥n `mutar(individuo)` introduce caos controlado. Con una probabilidad del 20%, tomamos un sorteo, elegimos dos grupos al azar e intercambiamos dos equipos del mismo bombo.

Si muta:
  1. Elige 2 grupos al azar
  2. Elige un bombo al azar (1, 2, 3, o 4)
  3. Intercambia los equipos de ese bombo entre los 2 grupos
  4. Solo si ninguno tiene grupo fijo

```python
def mutar(individuo, prob_mutacion):
    """
    Intenta mutar con probabilidad 'prob_mutacion'.
    """
    if random.random() > prob_mutacion:
        return individuo  # No muta

    # Si muta, hacemos el intercambio
    nuevo = copy.deepcopy(individuo)
    idx_g1, idx_g2 = random.sample(range(12), 2)
    bombo_idx = random.randint(0, 3)

    e1 = nuevo[idx_g1][bombo_idx]
    e2 = nuevo[idx_g2][bombo_idx]

    if not e1.grupo_fijo and not e2.grupo_fijo:
        nuevo[idx_g1][bombo_idx], nuevo[idx_g2][bombo_idx] = (
            nuevo[idx_g2][bombo_idx],
            nuevo[idx_g1][bombo_idx],
        )

    return nuevo
```

### Reemplazo
La nueva generaci√≥n reemplaza completamente a la anterior (esto es debatible).

## Criterio de terminaci√≥n
Para terminar el ciclo de vida el valor no debe tener un criterio de terminaci√≥n. Uno de ellos terminar algoritmo si se alcanza la cantidad m√°xima de generaciones previamente estipuladas. El otro, si detecta que un individuo tiene un Fitness igual a cero, tambi√©n termina el algoritmo y toma este medio individuo como la soluci√≥n √≥ptima.

_Criterios de terminaci√≥n:_
- Si encuentra un sorteo con penalizaci√≥n = 0 -> ¬°√âxito!
- Si llega a generaci√≥n 1000 -> devuelve el mejor encontrado.

Afortunadamente, la estructura de bombos permite encontrar soluciones r√°pidamente con los algoritmos gen√©ticos y no hay que recurrir al critero de generaci√≥n de terminaci√≥n.

## Para finalizar (P.D.)
No es dif√≠cil (tomando en cuenta las cifras astron√≥micas de antes) encontrar algunas soluciones que coincidan con el sorteo llevado a cabo el 5 de diciembre de 2025. 
Por ejemplo en la imagen de abajo podemos ver en el grupo C, lo que result√≥ ser el grupo L del mundial.
![caption=Es normal ver casos que coinciden con los grupos reales del mundial 2026.](https://res.cloudinary.com/dcvnw6hvt/image/upload/v1765065317/elCronopio/Screenshot_2025-12-05_at_21.25.01_dck9wj.png)

<ReferenceList references={[
{id:"1", text:"Restricciones del sorteo de la FIFA", url:"https://www.fifa.com/es/tournaments/mens/worldcup/canadamexicousa2026/articles/sorteo-copa-mundial-2026-procedimiento-sorteo-final"},
    {id: "2", text:"Clasificaci√≥n Mundial Masculina FIFA/Coca-Cola.", url: "https://inside.fifa.com/es/fifa-world-ranking/men"},
    {id: "3", text:"Procedimiento del sorteo final de la Copa Mundial de la FIFA 2026‚Ñ¢", url:"https://digitalhub.fifa.com/m/3fd60e2399fe26ff/original/Procedimiento-del-sorteo-de-la-Copa-Mundial" },
    {id: "4", text:"John Holland, Adaptation in Natural and Artificial Systems, 1975", url: "https://mitpress.mit.edu/books/adaptation-natural-and-artificial-systems"},
    {id: "5", text:"Lawrence Fogel, Intelligent decision making through a simulation of evolution, 1966", url: "https://doi.org/10.1002/bs.3830110403"},
    {id: "6", text:"Larra√±aga et al, Genetic Algorithms for the Travelling Salesman Problem: A Review of Representations and Operators", url:"https://doi.org/10.1023/A:1006529012972"}
]}/>


