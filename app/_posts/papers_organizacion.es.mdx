---
slug: "papers_organizacion"
id: "python-01"
date: "2025-10-31"
order: 1
title: "Estandarización de Nombres de Papers con Python"
shortTitle: "Estandarización de Nombres de Papers con Python"
author: "Eric Lucero"
coverImage: https://res.cloudinary.com/dcvnw6hvt/image/upload/v1741389125/elCronopio/cover_test-2_dnehhh.jpg
excerpt: "Script para organizar papers académicos automáticamente con Python."
doctype: ["blog"]
isPublic: false
---

## De Caos a Orden: Cómo Automaticé la Organización de mis Papers con Python

Como todo estudiante de doctorado, mi carpeta de "Papers por leer" era un caos. Nombres como `final_v2.pdf`, `1234.5678.pdf` o `articulo_importante.pdf` hacían imposible encontrar nada. Cansado de perder tiempo, decidí aplicar lo que mejor sé hacer: usar Python para construir una herramienta que pusiera orden de una vez por todas.

En este post, te guiaré a través del proceso de creación de un script que:
1.  Vigila una carpeta de entrada (`_Inbox`).
2.  Extrae metadatos (Título, Autor, Año) de los archivos PDF.
3.  Renombra los archivos a un formato estándar y consistente.
4.  Lo hace de forma robusta y multiplataforma.

¡Vamos a transformar ese desorden en una biblioteca organizada!



## El Flujo de Trabajo: De `_Inbox` a la Gloria

La idea es simple. Todos los papers nuevos que descargo van a una única carpeta llamada `_Inbox`. Luego, ejecuto mi script de Python, que los procesa y los mueve a mi biblioteca principal, ya renombrados con el formato: **`Año-Titulo-resumido-(Autor).pdf`**.

## Paso 1: Extrayendo la Magia de los PDFs con `PyPDF2`

El primer desafío es conseguir la información que está dentro del PDF. Para esto, usaremos la librería `PyPDF2`. Nuestro objetivo es crear una función que, dado un archivo, nos devuelva el título, el autor y el año.

La clave es acceder a los **metadatos** del archivo, que es información guardada junto con el contenido principal.

```python
# En metadata_utils.py
import PyPDF2
import logging

def extract_pdf_metadata(pdf_file):
    """Devuelve (año, título, autor) a partir de los metadatos de un PDF."""
    try:
        with open(pdf_file, "rb") as f:
            reader = PyPDF2.PdfReader(f)
            meta = reader.metadata
            if meta:
                # Lógica para extraer y limpiar el año del campo 'CreationDate'
                year = meta.get("/CreationDate", "")[2:6]
                
                # Lógica para obtener y limpiar el título
                title = meta.get("/Title", "NoTitle").strip()
                
                # Lógica para obtener el apellido del primer autor
                author_full = meta.get("/Author", "Unknown").strip()
                author = author_full.split(",")[0].split()[-1]

                return year, title, author
    except Exception as e:
        logging.warning(f"No se pudieron leer los metadatos de {pdf_file.name}: {e}")
    
    return None, None, None
```
**Fundamento:** Usar un bloque `try-except` es crucial. Muchos PDFs de internet están corruptos o no tienen metadatos estándar. Nuestro script debe ser lo suficientemente robusto como para no fallar si se encuentra con uno de estos archivos.

## Paso 2: El Corazón del Sistema con `pathlib`

Para manejar las rutas de archivos, **olvídate de `os.path`**. La forma moderna, limpia y multiplataforma de hacerlo es con `pathlib`. Esta librería convierte las rutas de texto en objetos inteligentes.

La ventaja más visible es la unión de rutas. Es tan intuitivo como esto:
```python
from pathlib import Path

# La forma antigua y engorrosa
# ruta = os.path.join(base, carpeta, archivo)

# La forma moderna con pathlib
ruta = Path(base) / carpeta / archivo
```
Esta sintaxis no solo es más legible, sino que `pathlib` se encarga automáticamente de usar `/` o `\` según estemos en macOS/Linux o Windows.

Nuestra clase principal, `PaperOrganizer`, usará `pathlib` para todas las operaciones de archivos, como buscar PDFs en el `_Inbox`, renombrarlos y moverlos.

```python
# En manage_names.py
from pathlib import Path
import sys

class PaperOrganizer:
    def __init__(self, base_path: str):
        self.base_path = Path(base_path)
        self.inbox_path = self.base_path / "_Inbox"

    def rename_to_standard_format(self, filepath, year, title, author):
        path = Path(filepath)
        # Normalizamos el título para que sea un nombre de archivo válido
        title_normalized = title.replace(" ", "-")[:80] # Truncamos a 80 caracteres
        
        new_name = f"{year}-{title_normalized}-({author}).pdf"
        new_path = path.parent / new_name
        
        # El método .rename() también sirve para mover archivos
        path.rename(new_path)
        print(f"✅ Renombrado: {path.name} -> {new_name}")

    def add_macos_tag(self, pdf_file):
        """Añade una etiqueta 'Pending' solo si estamos en macOS."""
        if sys.platform == "darwin": # 'darwin' es macOS
            try:
                subprocess.run(["tag", "-a", "Pending", str(pdf_file)], check=True)
            except FileNotFoundError:
                print("⚠️  Comando 'tag' no encontrado. Instálalo con 'brew install tag'")

```
**Beneficios:** Al centralizar la lógica en una clase y usar `pathlib`, creamos un sistema cohesivo donde cada parte tiene una responsabilidad clara. El método `.rename()` de `pathlib` es tan versátil que sirve tanto para renombrar en el sitio como para mover el archivo a otra carpeta, simplificando nuestro código.

## Paso 3: Creando una Herramienta de Terminal con `argparse`

Para que nuestro script sea una verdadera herramienta, le añadimos una interfaz de línea de comandos (CLI) con `argparse`. Esto nos permite ejecutar diferentes acciones (`normalize`, `hyphenize`, etc.) de forma sencilla.

Además, usamos `python-dotenv` para gestionar la configuración (como la ruta principal a nuestros papers) de forma segura en un archivo `.env`, en lugar de escribirla directamente en el código.

```python
# En main.py
import os
from pathlib import Path
import argparse
from dotenv import load_dotenv

def main():
    load_dotenv() # Carga las variables de .env
    parser = argparse.ArgumentParser(description="Utilidad para organizar papers.")
    parser.add_argument("command", choices=["normalize", "hyphenize"], help="Función a ejecutar")
    args = parser.parse_args()

    # Leemos la ruta desde el entorno y la convertimos a un objeto Path
    PHD_PATH = os.getenv("my_path")
    if not PHD_PATH:
        raise ValueError("La variable 'my_path' no está definida en .env")
    
    base_dir = Path(PHD_PATH)
    organizer = PaperOrganizer(str(base_dir))

    if args.command == "normalize":
        organizer.batch_normalize_filenames(str(base_dir / "_Inbox"))
    # ... otras condiciones ...

if __name__ == "__main__":
    main()
```
**Fundamento:** Separar la configuración (`.env`) del código (`main.py`) es una práctica profesional estándar. Permite que otras personas (o tú mismo en otro ordenador) usen tu script simplemente creando su propio archivo `.env` sin tener que modificar la lógica del programa.

## Conclusion: Más allá de un simple script

Lo que empezó como una solución a una molestia personal se convirtió en una herramienta robusta y un excelente ejercicio de "Pythonic code". Este proyecto no solo me ahorra horas de trabajo manual, sino que también es una pieza de portafolio que demuestra mi dominio de:

- **Programación Orientada a Objetos** en Python.
- **Manipulación de archivos moderna y multiplataforma** con `pathlib`.
- **Procesamiento de datos** con `PyPDF2` para extraer información de PDFs.
- **Creación de herramientas de terminal** robustas con `argparse`.
- **Buenas prácticas de desarrollo** como el manejo de errores, logging y gestión de la configuración.

Espero que este desglose te sea útil y te inspire a automatizar tus propios flujos de trabajo. ¡El orden nunca había sido tan satisfactorio!

Puedes encontrar el código completo de este proyecto en mi [GitHub](https://github.com/EricLuceroGonzalez/Reading_planner).